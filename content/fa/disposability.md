## IX. دسترس‌پذیری
### با راه‌اندازی سریع و توقف تدریجی نرم‌افزار، دسترس‌پذیری را به حداکثر برسانید

**[پردازه‌های](./processes) برنامه‌ی دوازده-سازه *یکبار مصرف* هستند، به این معنی که می توان آنها را در یک آن، ایجاد یا متوقف کرد.** این کار مقیاس‌پذیری سریع و منعطف، استقرار سریع [کد](./codebase) یا [پیکربندی](./config) تغییرات و استحکام عملیات را تسهیل می‌کند.

پردازه‌ها می‌بایست **زمان راه اندازی حداقلی داشته باشند**. در حالت ایده‌آل، یک پردازه از زمان اجرای دستور راه‌اندازی، چند ثانیه طول می‌کشد تا آماده‌ی پردازش درخواست‌ها یا کارها شود. زمان راه‌اندازی کوتاه، چابکی بیشتری را برای فرایند [انتشار](./build-release-run) و افزایش مقیاس‌پذیری فراهم می‌کند. و به استحکام برنامه کمک می کند، زیرا مدیر سیستم در صورت لزوم می‌تواند به راحتی پردازه‌ها را به ماشین‌های فیزیکی جدید منتقل کند.

پردازه‌ها هنگامی که **سیگنال [SIGTERM](http://en.wikipedia.org/wiki/SIGTERM)** را از مدیر پردازه یا پردازه‌ی اصلی سیستم دریافت می‌کنند، به آرامی خاموش می‌شوند. برای یک پردازه‌ی وب، خاموش شدن تدریجی شامل توقف بررسی درخواست‌های رسیده به درگاه سرویس (و در نتیجه رد هر درخواست جدید)، اجازه دادن به تمام درخواست‌های کنونی و سپس خروج کامل و توقف پردازه به‌دست می‌آید. ضمناً اساس این مدل بر این اصل استوار است که درخواست‌های HTTP کوتاه هستند (کمتر از چند ثانیه)، یا در مورد درخواست‌هایی که به مدت زمان بررسی بیشتری نیاز دارند، سرویس‌گیرنده باید به‌طور یکپارچه تلاش کند تا زمانی که اتصال قطع شد، دوباره اتصال را برقرار کند.

برای یک پردازه‌ی کاری، با برگرداندن کار کنونی فعال به صف کارها، توقف تدریجی حاصل می‌شود. برای مثال، در [RabbitMQ](http://www.rabbitmq.com/) پردازه‌ی فعال، می تواند یک ['NACK'](https://www.rabbitmq.com/amqp-0-9-1-quickref#basic.nack) ارسال کند. در [Beanstalkd](https://beanstalkd.github.io)، هر زمان که یک پردازه‌ی فعال ارتباط خود را قطع کند، کار به طور خودکار به صف باز می‌گردد. سیستم‌های مبتنی بر قفل مانند [Delayed Job](https://github.com/collectiveidea/delayed_job#readme) باید حتماً قفل خود را در فهرست رکوردها، آزاد کنند. به طور ضمنی، این مدل بر اساس این اصل بنا شده که همه فرآیند‌ها [قابلیت توقف در حین اجرا](http://en.wikipedia.org/wiki/Reentrant_%28subroutine%29) دارند ، معمولاً با جمع‌آوری نتایج درخواست در یک تراکنش، یا استفاده از عملیات [با قابلیت تلاش مجدد بدون تأثیر بر نتیجه‌ی نهایی](http://en.wikipedia.org/wiki/Idempotence) به دست می‌آید.

پردازه‌های برنامه‌ی کاربردی همچنین باید **در برابر توقف ناگهانی** در صورت بروز خرابی در سخت‌افزار زیرین مقاوم باشند. در حالی که این اتفاق بسیار نادرتر از یک توقف تدریجی با سیگنال «SIGTERM» است، اما همچنان احتمال رخداد آن وجود دارد. یک رویکرد توصیه‌شده استفاده از یک مکانیزم صف قوی، مانند Beanstalkd است، که در صورت قطع اتصال مشتریان یا پایان مهلت سرویس‌گیرنده برای دریافت پاسخ، کارها را به صف باز می گرداند. در هر صورت، یک برنامه‌ی دوازده-سازه برای مدیریت توقف‌های غیرمنتظره و غیر تدریجی طراحی شده است.  [نتایج منطقی](http://docs.couchdb.org/en/latest/intro/overview.html)  حاصل از این مفهموم در [طراحی شکست‌محور](http://lwn.net/Articles/191059/) ظاهر می‌شود.