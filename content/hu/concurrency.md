## VIII. Párhuzamos folyamatok
### Méretezés a folyamatmodell segítségével

Minden számítógépes program futtatása egy vagy több *folyamatot (process)* jelent. A webes alkalmazások sokféle folyamatvégrehajtási formát öltenek. Például a PHP folyamatok az Apache által a háttérben indított alfolyamatokként (child process) futnak, és a kérések mennyiségéhez igazodva indulnak. A Java folyamatok éppen ellenkezőleg, a JVM egy méretes főfolyamatot (uberprocess) szolgáltat, ami induláskor a rendszer (CPU és memória) erőforrásainak egy jelentős részét lefoglalja, és a párhuzamosságot belsőleg, szálakon keresztül kezeli. Mindkét esetben a futó folyamat(ok) csak minimális szinten láthatók az alkalmazás fejlesztője szemszögéből.

![A méretezést (scale) fejezzük ki a futó folyamatok számában, a terhelés sokféleségét pedig fejezzük ki különböző folyamattípusokban.](/images/process-types.png)

**A tizenkét tényezős alkalmazásokban a folyamatok elsőrendű állapolgárok.** A folyamatok a tizenkét tényezős alkalmazásban nagyon erősen másolják [a unix világ folyamatmodelljét ami szolgáltatás daemon-okat futtat](https://adam.herokuapp.com/past/2011/5/9/applying_the_unix_process_model_to_web_apps/).  Ezt a modellt felhasználva, a fejlesztő az eltérő terhelésekhez feladattípusonként a megfelelő *folyamattípusokat* rendelve építheti fel az alkalmazását. Például a HTTP kéréseket kiszolgálhatják web folyamatok, a hosszú ideig futó háttérfeladatokat pedig kiszolgálhatják munkavégző (worker) folyamatok.

Ez nem zárja ki, hogy az egyes folyamatok a saját belső párhuzamos tevékenységüket (multiplexing) több szálon kezeljék a futó virtuális gép (VM) belsejében, vagy alkalmazzák az [EventMachine](http://rubyeventmachine.com/), a [Twisted](http://twistedmatrix.com/trac/), vagy a [Node.js](http://nodejs.org/) és hasonló környezetekben megtalálható aszinkron/eseményvezérelt felépítést.  De egy adott virtuális gép (VM) maga csak véges nagy lehet (függőlegesen átméretezve -vertical scale- a gépet csak akkorára tudjuk megnövelni, amekkorát a környezet lehetővé tesz), így az alkalmazásnak arra is képesnek kell lennie, hogy több fizikai gépre leosztva futtassa (vízszintesen átméretezve - horizontal scale) a különböző folyamatokat párhuzamosan.

A folyamatmodell ereje akkor tünik fel igazán, amikor eljön az idő, és a megnövekedett terhelésre válaszul az egyszerre kiszolgáló folyamatok számát meg tudjuk növelni (vizszintesen lehet méretezni -horizontal scale). A [A tizenkét tényezős alkalmazás folyamatok között semmit sem megosztó, így párhuzamosan (vízszintesen) építhető természetének köszönhetően](./processes) a párhuzamos végrehajtási kapacitás növelése egyszerűen, megbízható módon, vagyis kis kockázattal elvégezhető művelet.  A különböző folyamattípusok együttese és ezen belül az egyes folyamattípusokból futó folyamatok számát szokás *folyamatösszeállítás* (process formation) névvel hivatkozni.

A tizenkét tényezős alkalmazás [sosem démonizálódik](http://dustin.github.com/2010/02/28/running-processes.html) vagy ír PID állományt (tehát nem önállóan, saját maga kezeli a folyamatait).  Helyette az operációs rendszer folyamatvezérlőjére támaszkodik (mint a [systemd](https://www.freedesktop.org/wiki/Software/systemd/), vagy felhős környezetben az elosztott folyamatok vezérlője, vagy fejlesztési környezetben a [Foreman](http://blog.daviddollar.org/2011/05/06/introducing-foreman.html)-hoz hasonló eszközök) a [kimeneti adatsorok](./logs) (output streams) kezeléséhez, a bedőlt folyamatokra (crashed processes) adott válaszhoz vagy a felhasználó által kezdeményezett újraindítások (restart) és leállítások (shutdown) kezeléséhez.
