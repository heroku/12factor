## IX. Megszüntethetőség
### Az elérhető legnagyobb ellenálló képesség villámgyors indulással és kulturált leállással

**A tizenkét tényezős alkalmazás [folyamatai](./processes) *megszüntethetőek*, ami azt jelenti, hogy pillanatok alatt képesek elindulni vagy leállni.** Ez támogatja a gyors, rugalmas méretezést, a [kód](./codebase) vagy [konfiguráció](./config) változásának gyors üzembehelyezését (deployment), és az éles üzembehelyezések (production deployment) nagy ellenálló képességét.

A folyamatoknak törekedniük kell **az elindulásukhoz szükséges idő minimalizálására**. Ideális esetben egy folyamatnak néhány másodpercig tart az indulási parancstól eljutni egészen addig, hogy a folyamat dolgozik és kész a kérések vagy a feladatok fogadására. A rövid indulási idő nagyobb rugalmasságot biztosít a [közzétételi folyamathoz](./build-release-run) és az átméretezéséhez (scaling up); segíti az ellenálló képességet, ugyanis ha szükséges, a folyamatkezelő könnyebben át tudja mozgatni a folyamatot egy új fizikai eszközre.

**A folyamat álljon le kulturáltan, ha megkapja a [SIGTERM](http://en.wikipedia.org/wiki/SIGTERM)** jelzést a folyamatkezelőtől. Webes folyamatoknál a kulturált leállás elérhető, ha megszünik a szolgáltatás portján a kiszolgálás (listening) (ezzel minden új kérést visszautasítva), engedélyezi bármelyik folyamatban lévő kérés befejezését, ezután kilép. Ebben a modellben az is benne van, hogy vagy a HTTP kérések rövidek (nem több néhány másodpercnél), vagy a hosszú ideig tartó hívásokkal történő folyamatos lekérdezés ([long polling](https://www.pubnub.com/blog/2014-12-01-http-long-polling/)) esetén a kliens zökkenőmentesen próbál újrakapcsolódni, ha a kapcsolat megszakad.

Munkavégző folyamatok esetén a kulturált leállás elérhető az aktuális végrehajtás alatt lévő feladat visszahelyezésével a várakozósorba. Például a [RabbitMQ](http://www.rabbitmq.com/) üzenetsor esetén a munkavégző folyamat küldhet egy  [`NACK`](http://www.rabbitmq.com/amqp-0-9-1-quickref.html#basic.nack) üzenetet; míg [Beanstalkd](http://kr.github.com/beanstalkd/) esetén a feladat automatikusan visszakerül a várakozósorba, ha a munkavégző felé megszakad a kapcsolat. A [Delayed Job](https://github.com/collectiveidea/delayed_job#readme)-hoz hasonló zárolás alapú rendszereknél fontos, hogy a zárolást ilyenkor a feladat rekordján feloldjuk. A modellünknek a része, hogy minden feladat [ismételhető](http://en.wikipedia.org/wiki/Reentrant_%28subroutine%29) kell, hogy legyen, ami tipikusan a feladatok tranzakcióba burkolásával, vagy a műveletek [idempotenssé](http://en.wikipedia.org/wiki/Idempotence) tételével (az első feladatvégzés után a további ismétlések nem változtatják az eredményt) érhető el.

A folyamatoknak **ellenállóknak kell lenniük hirtelen halállal szemben** is, a futtató hardvereszköz meghibásodásának az esetén. Habár ez sokkal ritkábban előforduló esemény, mint a (`SIGTERM`) jelzés hatására történő kulturált leállás, azért előfordulhat. A javasolt megközelítés egy nagy ellenálló képességű üzenetsor használata, mint például a Beanstalkd, ami egyszerűen visszahelyezi a feladatot a várakozósorba, ha kapcsolat megszakad az ügyfélprogram felé vagy a kliens időtúllépésbe kerül. Akárhogy is, a tizenkét tényezős alkalmazás a váratlan, nem kulturált leállások kezelésére megfelelő felépítéssel van felkészítve. Ez az elképzelés [logikus végkövetkeztetésként](http://docs.couchdb.org/en/latest/intro/overview.html) a [kizárólag összeomlásra (crash-only) irányuló tervezési módot](http://lwn.net/Articles/191059/) választja.


