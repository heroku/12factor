## IX. Descartabilidad
### Maximizar la robustez con un inicio rápido y un cierre elegante

**Los [procesos](./processes) del app twelve-factor son *descartables*, significa que se puede iniciar o parar en cualquier momento.** Esto facilita a escalar de forma rápida y elástica, al lanzamiento rápido de cambios en el [código](./codebase) o en la [config](./config), y a la robustez de los deploys en producción.

Los procesos deben esforzarse por **minimizar el tiempo de inicio**. Idealmente, un proceso se demora solo unos segundos desde el momento de ejecutar el comando de lanzar, hasta que el proceso esté en marcha y lista para recibir peticiones o tareas. Un tiempo de inicio corto resulta en más agilidad para el proceso de [lanzar](./build-release-run) y para escalar hacia arriba; y aporta a la robustez, porque el gestor de procesos puede trasladar los procesos a nuevas máquinas físicas de forma más facil, cuando sea necesario.

Los procesos **se apagan con elegancia cuando reciben una [SIGTERM](http://en.wikipedia.org/wiki/SIGTERM)** señal del gestor de procesos. Para un proceso web, apagar con elegancia se logra por cesar de escuchar en el puerto de servicio (y así rechazar todas nuevas peticiones), dejar que todas peticiones actuales se terminen, y luego terminar. En este modelo es implícito que las peticiones HTTP son cortas (no más que unos segundos), o en el caso de "polling largo", el cliente debe (de forma continua) intentar reconectar cuando la conexión se pierde.

Para un proceso trabajador, apagar con elegencia se logra por devolver la tarea actual a la fila de tareas. Por ejemplo, en [RabbitMQ](http://www.rabbitmq.com/) el trabajador puede enviar un [`NACK`](http://www.rabbitmq.com/amqp-0-9-1-quickref.html#basic.nack); en [Beanstalkd](http://kr.github.com/beanstalkd/), la tarea se devuelve a la fila automáticamente cuando un trabajador se desconecta. Sistemas con cerrojo como [Delayed Job](https://github.com/collectiveidea/delayed_job#readme) deben fijarse en soltar su cerrojo en el registro de tareas. En este modelo es implícito que todas tareas son [re-entrantes](http://es.wikipedia.org/wiki/Reentrancia_%28inform%C3%A1tica%29), lo que normalmente se logra por envolver los resultados en una transacción, o por hacer que la operación sea [idempotente](http://es.wikipedia.org/wiki/Idempotencia).

Los procesos también deben ser **resistentes contra la muerte súbita**, en el caso de un fallo en el hardware de fondo. Aunque esto sea un caso mucho menos común que apagar con elegancia con `SIGTERM`, igual puede pasar. Una estrategia recomendada es el uso de un sistema de fila robusto, como Beanstalkd, que devuelve las tareas a la fila cuando los clientes se desconectan o expiran. En ambos casos, un app twelve-factor está diseñado para aguantar las terminaciones que vienen imprevistas y sin elegancia. [Diseño solo-caer](http://lwn.net/Articles/191059/) lleva este concepto hacia su [conclusión lógica](http://docs.couchdb.org/en/latest/intro/overview.html).
