## IX. Desechabilidad
### Maximizar la robustez con un inicio rápido y un cierre grácil

**Los [procesos](./processes) del app twelve-factor son *desechables*, lo que significa que se pueden iniciar o parar en cualquier momento.** Esto facilita un escalado rápido y elástico, un despliegue rápido de cambios en el [código](./codebase) o en la [configuración](./config), y pases a producción más robustos.

Los procesos deben esforzarse por **minimizar el tiempo de inicio**. Idealmente, un proceso tardará solo unos segundos desde el momento de ejecutar el comando de arranque hasta que el proceso esté en preparado para recibir peticiones o tareas. Un tiempo de inicio corto proporciona más agilidad para el proceso de [lanzamiento](./build-release-run) y de escalado vertical, y mejora la robustez porque el gestor de procesos puede trasladar los procesos a nuevas máquinas físicas más facilmente si es necesario.

Los procesos **se paran grácilmente cuando reciben una señal [SIGTERM](http://en.wikipedia.org/wiki/SIGTERM)** del gestor de procesos. Para un proceso web, parar con gracilidad se consigue dejando de escuchar en el puerto de servicio (rechazando así cualquier nueva petición), dejando que todas las peticiones actuales se completen, y finalmente parando. Este modelo implica que las peticiones HTTP sean cortas (no más que unos segundos) o, en el caso de hacer "long polling", el cliente debe (de forma continua) intentar reconectar cuando se pierde la conexión.

Para una tarea, se consigue parar con elegancia devolviendo la tarea actual a la cola de tareas. Por ejemplo, en [RabbitMQ](http://www.rabbitmq.com/) la tarea puede enviar un [`NACK`](http://www.rabbitmq.com/amqp-0-9-1-quickref.html#basic.nack); en [Beanstalkd](http://kr.github.com/beanstalkd/), la tarea se devuelve a la cola automáticamente cuando el proceso se desconecta. Los sistemas con lock como [Delayed Job](https://github.com/collectiveidea/delayed_job#readme) deben estar pendientes y liberar el lock en el registro de tareas. Este modelo implica que todas tareas deben ser [re-entrantes](http://es.wikipedia.org/wiki/Reentrancia_%28inform%C3%A1tica%29), lo que normalmente se logra envolviendo los resultados en una transacción, o haciendo que la operación sea [idempotente](http://es.wikipedia.org/wiki/Idempotencia).

Los procesos también deben **resistir una muerte súbita**, en el caso de un fallo en el hardware. Aunque este caso es mucho menos frecuente que una señal `SIGTERM`, puede ocurrir igualmente. Una estrategia recomendada es el uso de un sistema de colas robusto, como Beanstalkd, que devuelve las tareas a la cola cuando los clientes se desconectan o dejan de responder. En ambos casos, una aplicación twelve-factor está diseñada para aguantar paradas imprevistas y no gráciles. El [diseño crash-only](http://lwn.net/Articles/191059/) lleva este concepto a su [conclusión lógica](http://docs.couchdb.org/en/latest/intro/overview.html).
