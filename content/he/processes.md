## VI. תהליכים
## הרץ את האפליקציה כתהליך אחד או יותר ללא שמירת מצב

האפליקציה מורצת בסביבה כ*תהליך* אחד או יותר

במצב הפשוט ביותר, הקוד הוא סקריפט בודד, סביבת ההרצה היא המחשב הפרטי של המפתח שבה מותקנת סביבת ההרצה של התכנה והתהליך מורץ דרך שורת הפיקודים (למשל, `python my_script.py`). בקצה השני של הספקטרום, הורדת גרסה לייצור משתמשת בהרבה [סוגים שונים של תהליכים, אשר מורצים כאפס או יותר תהליכים רצים](./concurrency).

**תהליכים על פי מתוגולוגיית שניים-עשר הגורמים רצים ללא מצב (Stateless) [ולא משתפים דבר](http://en.wikipedia.org/wiki/Shared_nothing_architecture).** כל מידע שנדרש להישמר לאורך זמן נשמר [בשירותים מגבים](./backing-services), בדרך כלל בבסיס נתונים.


ניתן להשתמש במרחב הזכרון או במערכת הקבצים לרגעים קצרים, עבור מקרים קצרים בלבד. לדוגמא, הורדת קובץ גדול, ביצוע עיבוד עליו ושמירת התוצאה בבסיס נתונים. תהליך אשר מממש את עקרונות שניים-עשר הגורמים לעולם לא יניח דבר על קיום של מידע בזכרון או בדיסק לאורך זמן -- כאשר ישנם תהליכים רבים של אותה תכנה אשר רצים במקביל, רוב הסיכויים שבקשה עתידית תיענה על ידי תהליך אחר. אפילו אם מריצים תהליך בודד, אתחול מחדש (עקב הורדת גרסה, שינוי בקונפיגורציה וכד') בדר"כ תגרום למחיקת המידע המקומי (לדוגמא הזכרון או מערכת הקבצים)

מערכות לניהול חבילות כמו [django-assetpackager](http://code.google.com/p/django-assetpackager/) משתמשות במערכת הקבצים לניהול התוצרים. מתודולוגיית שניים-עשר הגורמים תעדיף לבצע זאת [בשלב הבנייה] (/build-release-run). ניתן להגדיר את מערכות לניהול חבילות כמו [Jammit](http://documentcloud.github.com/jammit/) וגם [Rails asset pipeline](http://ryanbigg.com/guides/asset_pipeline.html) לשמור את התוצרים בשלב הבנייה.

ישנם מערכות ווב אשר נשענות על ["Sticky Session"](http://en.wikipedia.org/wiki/Load_balancing_%28computing%29#Persistence) -- כלומר, שמירת המידע של המשתמש בזכרון של האפליקציה וציפייה שבקשות עתידיות מאותו משתמש יגיעו לאותו התהליך. Sticky Sessions מהוות הפרה של מתודולוגיית שניים-עשר הגורמים ואין להשתמש בהן או להישען עליהן. מידע על חיבור של משתמש ניתן לשמור בבסיסי נתונים שמאפשרים שמירה לזמן קצוב, כמו [Memcached](http://memcached.org/) או [Redis](http://redis.io/).