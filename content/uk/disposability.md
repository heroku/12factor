## IX. Одноразовість
### Максимізуйте надійність за допомогою швидкого запуску та коректного вимкнення

**[Процеси](./processes) 12-факторного застосунку є *одноразовими*, вони можуть бути запущені або зупинені в будь-який момент.** Це сприяє гнучкому масштабуванню, швидкому розгортанню [коду](./codebase) або змінам [конфігурації](./config) та надійності production-розгортання.

Слід намагатися **мінімізувати час запуску процесів**. В ідеалі час між моментом виконання команди запуску процесу і моментом, коли процес готовий приймати запити чи задачі, має тривати лише декілька секунд. Короткий час запуску забезпечує більшу гнучкість для випуску [релізів](./build-release-run) і масштабування. Крім того, це підвищує надійність, оскільки менеджер процесів може легко переміщувати процеси на нові фізичні машини у разі необхідності.

Процеси мають **коректно завершувати свою роботу, коли вони отримують сигнал [SIGTERM](http://en.wikipedia.org/wiki/SIGTERM)** від диспетчера процесів. Для вебпроцесу коректне завершення роботи досягається завдяки припиненню прослуховування порту, до якого він привʼязаний (що означає відмову від отримання будь-яких нових запитів), завершенню обробки будь-яких поточних запитів та зупинці самого процесу. В цій моделі передбачається, що HTTP-запити короткі (не більше ніж кілька секунд), а у разі довгих запитів (long polling) клієнт має намагатися відновити зʼєднання у разі його втрати.

Для процесу, що виконує фонові задачі (worker), коректне завершення роботи досягається внаслідок повернення поточного завдання назад у чергу задач. Наприклад, в [RabbitMQ](http://www.rabbitmq.com/) робочий процес може надіслати команду [`NACK`](http://www.rabbitmq.com/amqp-0-9-1-quickref.html#basic.nack); в [Beanstalkd](https://beanstalkd.github.io) завдання повертається в чергу автоматично щоразу, коли процес втрачає зʼєднання. Системи, що використовують блокування, такі як [Delayed Job](https://github.com/collectiveidea/delayed_job#readme), мають обовʼязково внести відповідний запис в робочий процес при розблокуванні задачі. Неявним у цій моделі є те, що всі завдання є [повторними](http://en.wikipedia.org/wiki/Reentrant_%28subroutine%29), що, як правило, досягається шляхом обгортання результатів у транзакцію або створення операції як [ідемпотентної](http://en.wikipedia.org/wiki/Idempotence).

Процеси також мають бути **стійкими до раптової зупинки** в разі відмови апаратних засобів, на яких вони запущені. Хоча це менш ймовірна подія, ніж коректне завершення роботи за допомогою сигналу `SIGTERM`, вона все ж таки може статися. Рекомендованим підходом є використання надійних черг завдань, таких як Beanstalkd, які повертають завдання в чергу задач, коли клієнти втрачають зʼєднання або відʼєднуються по тайм-ауту. У будь-якому випадку, 12-факторний застосунок має проєктуватися таким чином, щоб обробляти несподівані та некоректні припинення роботи. Реалізація архітектури ["тільки аварійного вимкнення" (Crash-only design)](http://lwn.net/Articles/191059/) доводить цю концепцію до [логічного завершення](http://docs.couchdb.org/en/latest/intro/overview.html).
